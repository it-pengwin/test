

# Индексы и партиции



## Объяснение на пальцах:


Давайте представим, что у нас есть мешок с кубиками, на которых номерки:




**1. Таблица без индексов и партиций (Просто мешок)**
Как выглядит:
![image](https://github.com/user-attachments/assets/4c170aee-a1be-4256-bbd0-7b418c1802c3)
Есть один большой мешок, куда все номерки (данные) бросаются в случайном порядке.

Пример:
```
CREATE TABLE bags (

  number_cube INT  -- цифра на кубике
  
);
```
Как работает:

Чтобы найти нужный номерок (number_cube=5), придётся перебрать весь мешок вручную - сканируем всю таблицу (Full Scan).

Плюс: Быстрая запись (просто кидаем в мешок).

Минус: Медленный поиск.

**2. Таблица с партициями (Несколько мешков с разделением)**

Как выглядит:

Несколько мешков, разделённых по правилу. Например, можно брать на каждый диапазон номеров новый мешок - 1-10 мешок №1, 11-20 мешок №2, 21-30 мешок №3 и тд.
Когда нам нужно найти кубик с номеров 15, мы сразу идем в мешок №2 и просматриваем только 10 кубиков (11-20).


Или можно представить, что у кубиков еще есть цвета (нейронка не смогла числа  нарисовать, ну ничего страшного):

![image](https://github.com/user-attachments/assets/d82691e4-35b3-4292-b9b2-dfd2ef23be60)


Пример:

```
CREATE TABLE partitioned_bags (

    number_cube INT,
    
    color VARCHAR(20)  -- Цвет номерка (ключ партиции)
    
) 
PARTITION BY LIST (color);

-- Создаём отдельные мешки для каждого цвета

CREATE TABLE bags_red PARTITION OF partitioned_bags FOR VALUES IN ('red');

CREATE TABLE bags_blue PARTITION OF partitioned_bags FOR VALUES IN ('blue');
```
Как работает:

Если ищем красный номерок (color='red'), СУБД полезет только в мешок bags_red.

Плюс: Ускорение поиска по ключу партиции.

Минус: Если ищем без указания цвета — проверяем все мешки. Чуть сложнее сопровождать, чем таблицу без партиций.

*Если мало данных (<1млн) нет смысла делить таблицу по партициям. Прироста производительности не будет.

**3. Таблица с индексом (Мешок + каталог номерков)**

Если все 1000 лежат в перемешку (мешок), нам нужно просмотреть все кубики, пока не найдем нужный. Можем найти его первым, а можем 1000-ым. А если мы будем знать, что среди кубиком **могут быть повторения** номерков, тогда мы будем **обязаны** всегда смотреть **все 1000** кубиков. 

Индекс может ускорить поиск номерков.

Можно представить, что у нас вообще нет мешка и все кубики лежат **отсортированные** и тогда мы найдем нужный номерок быстрее. 

Допустим, на полу лежат 1000 кубиков отсортированные от 1 до 1000. 

Нужно достать номер 410. Нам не нужно смотреть каждый номерок, мы будем просмотреть сразу большим срезами. Например, находим кубик с номером 500. 410<500, значит правую половину (501-1000) мы сразу отсекаем, она нам не подходит. Далее находим 250. 250<410 - отсекаем левую часть (1-250) и тд. Мы найдем наш номерок за несколько шагов. 

Такой индекс будет называться **кластерным**, когда не создается дополнительная сущность, а сразу вся таблица сортируется.


Минус: мы будем дольше записывать данные. Например, number_cube=5 мы не можем записать в конец, как было раньше (просто кинули в мешок), а должны найти подходящее место в списке и все оставшиеся кубики подвинуть (перестроить индекс). 


Другой вариант **некластерный** индекс.

Как выглядит:

У нас есть как раньше один мешок, но есть еще отдельный список (индекс), где записано:
«Номерок 5 лежит на дне, номерок 12 — у горловины».

Пример:

```
CREATE TABLE indexed_bags (
    number_cube INT
);

-- Создаём "каталог" для быстрого поиска номерков

CREATE INDEX idx_number ON indexed_bags (number_cube);
```

Как работает:

При поиске number_cube=5 СУБД сначала смотрит в индекс (каталог). Так как в каталоге все **отсортировано**, СУБД быстро находит нужный номер, где в соседней ячейке будут написаны координаты положения этого кубика в мешке (в таблице это ctid или rowid). Далее СУБД знает координаты местоположения кубика в мешке (всей строки, например с 30 полями) и быстро находит его, не просматривая все кубики из мешка. 

Плюс: Быстрый поиск по number_cube.

Минус: Запись медленнее (нужно обновлять и мешок, и каталог). Необходимо еще место на диске для католога. Неоптимизированный индекс может весить больше, чем сама таблица.


**Когда что использовать?**

- Просто мешок — если данные пишутся часто, а читаются редко (логи).

- Несколько мешков (партиции) — если данные можно чётко разделить (например, по дате, по региону, по бизнес сегменту).

- Мешок + каталог(индекс) — если нужен быстрый поиск по ключевому полю (id, email). Если это поле используется в условии соединения таблиц, или в where, group by, order by и тд. Если выбирается небольшой процент данных, до 5%. Объем данных свыше 5% эффективнее "фулл сканить". 





С детскими аналогиями закончим :)

Теперь попробую рассказть основное про партиции и индексы:

# **Индексы**

**Индексы в базах данных** — это специальные структуры, ускоряющие поиск и сортировку данных. Они работают подобно оглавлению в книге, позволяя СУБД быстро находить строки без полного сканирования таблицы.

Здесь есть различия у разных субд


В целом, какие есть показания к применению индексов:
5%
инсерт  апдейт редкие
поля участвуеют в соединении фильтрах
низкая селективность
и тд



## Классификация индексов

Это основной раздел по индексам. Индексы можно делить по группам по разным признакам.


### Кластеризованные и некластеризованные индексы

**Кластеризованный индекс** — индекс, который сортирует строки с данными в таблице. Кластеризованный индекс хранит данные в листьях индекса. Главная особенность кластеризованного индекса заключается в том, что все значения отсортированы в определенном порядке либо по возрастанию, либо по убыванию. Следует отметить, что данные в таблице хранятся в отсортированном виде только в том случае, когда у этой таблицы создан кластеризованный индекс. При использовании кластерного индекса данные упорядочены физически (т.е. хранятся, например, на жестком диске). Благодаря этому существенно возрастает скорость поиска данных (при условии последовательного доступа к данным). Однако операция, связанная с изменением порядка данных, может быть затратной и требовать перестроения. В отличие от обычных индексов, кластеризованный индекс создается на всю таблицу сразу, а не на один или более столбцов. В таблице может присутствовать только один кластеризованный индекс.

**Некластеризованный индекс** — индекс, который используется для применения индексов к неключевым столбцам. Главное отличие от кластеризованного индекса заключается в том, что некластеризованный индекс не упорядочивает данные физически. Некластеризованный индекс хранит данные и индексы в разных местах. Листья некластеризованного индекса содержат только те столбцы таблицы, по которым определен данный индекс. Это означает, что системе запросов необходима дополнительная операция для извлечения требуемых данных. Некластеризованные индексы нельзя отсортировать, в отличие от кластеризованных, однако существует возможность создания более одного некластеризованного индекса. Также при использовании некластеризованного индекса можно добавить уникальный ключ для таблицы.



|Кластеризованный индекс | Кластеризованный индекс |
| ------------- | ------------- |
|Производит сортировку и физическое хранение данных в соответствии с правилом сортировки | Не упорядочивает хранение данных физически. Вместо этого используются метки для доступа к данным  |
| Данные хранятся на конечных листьях (узлах) индекса | Не хранит данные на конечных листьях (узлах) индекса  |
| Занимает много места на диске l  |Чаще занимает мало места на диске  |
| Быстрый доступ к данным  | Медленнее доступ к данным  |
| Дополнительное место на диске не нужно | Необходимо дополнительное место на диске в связи с тем, что индекс хранится отдельно от данных |
| Может повысить производительность при извлечении требуемых данных | Применяется только к тем столбцам, которые используются в запросах с соединениями (join)  |


### Уникальные и неуникальные индексы

**Уникальный** (Unique index) — все значения встречаются только один раз. Если в столбец с уникальным индексом попробовать добавить неуникальное значение, то возникнет ошибка.

**Неуникальный** (Non-unique index) — индекс, при котором значения могут повторяться.


### Простые и составные  индексы

**Простой** (Simple index) — индекс, состоящий из одного поля.

**Составной** (Composite Index) — индекс, который строится по нескольким столбцам таблицы. В данном типе индекса расположение полей является важным.


### Классификация по структуре

1.1. B-деревья (B-Tree и B+Tree)
B-Tree – сбалансированное дерево, где каждый узел содержит ключи и указатели на дочерние узлы.

Структура: Сбалансированное дерево, где каждый узел содержит ключи и ссылки на дочерние узлы.

Как работает:

Данные сортируются по ключу.

Поиск происходит за O(log n) (быстро даже для больших таблиц).

Где используется: Стандартные индексы в реляционных БД (PostgreSQL, MySQL InnoDB, Oracle).

Пример: SELECT * FROM users WHERE id = 123;

B+Tree (используется в MySQL, PostgreSQL) хранит данные только в листьях, что ускоряет сканирование диапазонов.


B+Tree – улучшенная версия, где данные хранятся только в листьях, а внутренние узлы содержат ключи для быстрого поиска.

Применение:

Стандартные индексы в PostgreSQL, MySQL (InnoDB), Oracle, SQL Server.

Подходят для диапазонных запросов (WHERE age BETWEEN 18 AND 30).



Здесь еще хочется упоминуть

Что такое реверсивные индексы?
Реверсивный индекс — это особый вид B-Tree индекса, где ключи хранятся в обратном порядке (например, значение 1234 становится 4321).

Пример:

Оригинальный ключ: 1001, 1002, 1003

В реверсивном индексе: 1001 → 1001, 1002 → 2001, 1003 → 3001

2. Зачем они нужны?
Основная цель — снижение конкуренции (contention) в высоконагруженных OLTP-системах, особенно при вставке последовательных значений (например, автоинкрементных ID).

Проблема, которую решают:

В обычном B-Tree индекс с последовательными ключами (1, 2, 3, ...) все новые записи попадают в один "правый" лист дерева, создавая "горячую точку" (hot spot).

Реверсивный индекс распределяет вставки равномерно по всему дереву.

3. К какому классу индексов относятся?
Реверсивные индексы — это модификация B-Tree индексов, поэтому их можно отнести к:

Структурная классификация: B-Tree (но с изменённым порядком ключей).

Функциональная классификация: Специализированные индексы для оптимизации вставок.

4. Где применяются?
Базы данных с высокой частотой вставок: Oracle, PostgreSQL (частично), некоторые NoSQL-системы.

Сценарии:

Таблицы с автоинкрементными первичными ключами.

Системы, где много параллельных транзакций вставляют данные в одну таблицу.

1.2. Хеш-индексы (Hash Indexes)
Используют хеш-функцию для быстрого доступа к данным.

Структура: Хеш-таблица, где ключ преобразуется в числовой хеш (через хеш-функцию).

Как работает:

Точечный поиск за O(1) (очень быстро).

Не поддерживает сортировку и диапазонные запросы.

Где используется: Memcached, Redis, иногда в PostgreSQL (для точных запросов).

Пример: SELECT * FROM sessions WHERE session_id = 'abc123'


Плюсы:

Мгновенный поиск по точному совпадению (WHERE id = 123).

Минусы:

Не поддерживают диапазонные запросы и сортировку.

Коллизии хешей могут снижать производительность.

Применение:

Memcached, Redis (в памяти).

В PostgreSQL и MySQL (только для точных запросов).

1.3. Bitmap-индексы
Хранят битовые маски для каждого значения в столбце.
Структура: Битовая карта, где каждый бит соответствует строке с определённым значением.

Как работает:

Эффективен для столбцов с малым числом уникальных значений (например, gender).

Быстро выполняет логические операции (AND, OR).

Где используется: OLAP-системы (Oracle, ClickHouse).

Пример: SELECT * FROM employees WHERE department = 'HR' AND status = 'active';

Плюсы:

Эффективны для столбцов с малым количеством уникальных значений (например, gender).

Минусы:

Плохо масштабируются для часто изменяемых данных.

Применение:

OLAP-системы (Oracle, ClickHouse).

1.4. R-деревья (R-Tree)
Используются для пространственных данных (геообъекты, координаты).
Структура: Дерево для многомерных данных (например, геокоординат).

Как работает:

Группирует объекты в прямоугольные регионы (bounding boxes).

Оптимизирован для поиска в пространственных данных.

Где используется: PostGIS (PostgreSQL), гео-запросы.

Пример: SELECT * FROM places WHERE ST_Distance(location, 'POINT(10 20)') < 100;

Применение:

PostgreSQL (PostGIS), MySQL (индексы для GEOMETRY).

1.5. GiST, GIN, SP-GiST (PostgreSQL)
GiST (Generalized Search Tree) – универсальный индекс для сложных типов данных (геоданные, текстовый поиск).

GIN (Generalized Inverted Index) – для полнотекстового поиска и массивов.

SP-GiST (Space-Partitioned GiST) – для нерегулярных структур (IP-адреса).

GiST (Generalized Search Tree):

Универсальный индекс для сложных типов (геоданные, текстовый поиск).

Пример: CREATE INDEX idx_gist ON polygons USING GIST(geom);

GIN (Generalized Inverted Index):

Для составных данных (массивы, полнотекстовый поиск).

Пример: CREATE INDEX idx_gin ON documents USING GIN(to_tsvector('english', text));

SP-GiST (Space-Partitioned GiST):

Для нерегулярных структур (IP-адреса, точки в пространстве).



B-Tree — универсальный выбор для большинства задач.

Хеш — для мгновенного поиска по ключу.

R-Tree/GiST — для геоданных.

GIN — для полнотекста и массивов.

Bitmap — для аналитики по категориальным данным.

Виды индексов
кластенрный некластерны


б три
битмап
hash


локальный глобальный


когда используется


В оракле любят спрашивть про локальнгые и глобальные индексы.
Объяснгение.
В постгри такого разделения нект

testв



Индексы на самом деле очень сложная и глубокая тема. На моей прошлой работе в красном банке был один эксперт, который только и строил индексы, изучал планы и оптимизировал сложные запросы. И этим он занимается больше 10 лет, его очень ценят за глубокие знания. Но горизонтально он не сильно развивается и многие популярные инструменты он не знает, ему это неинтресно и пока что не нужно (это его слова).
В общем, поверхностно нужно понимать что такое индексы, какие-то базовые принципы, для чего и когда их полезно использовать. 

По индексам в интернете есть много статей, документации, видео. От себя могу порекомендовать:
- видео от разраба из Озона, как выбрать индекс https://youtu.be/DyqtBiDrz3g?si=xIw5OlHteTI1bfF3
- Канал Ораклиста, где он на пальцах разбирает разные концепции, пишет запросы и сравнивает планы запросов, можно смотреть в Яндекс браузере с переводчиком https://www.youtube.com/watch?v=DGAisQZxk-s
  




# **Партиции**
**Партиционирование** таблиц (оно же секционирование) - это метод проектирования базы данных, используемый для разделения большой таблицы на более мелкие, более управляемые фрагменты, называемые разделами. Каждый раздел по сути является отдельной таблицей, которая хранит подмножество исходных данных. Этот метод может значительно улучшить производительность запросов и управление данными для больших наборов данных.

Разделение может быть выполнено на основе одного или нескольких столбцов, таких как столбец даты или диапазон значений. Например, вы можете разбить таблицу на основе даты записей, где каждый раздел представляет данные для определенного диапазона дат. При запросе данных СУБД может быстро исключить разделы, которые не имеют отношения к запросу, что приводит к более быстрому выполнению запроса.

Каждый раздел — это отдельный сегмент таблицы, которым можно управлять независимо. Например, вы можете разделить данные о продажах по годам, при этом каждый год будет находиться в своем собственном разделе.

Большинство СУБД позволяет дробить партиции еще на секции - субпартиции.

Преимущества разбиения таблиц
1. Улучшенная производительность запросов : Разделение позволяет базе данных быстро сузить данные до определенного раздела, уменьшая объем данных, которые необходимо сканировать во время запросов. Это приводит к более быстрому времени выполнения запросов, особенно для больших наборов данных.

2. Более простое управление данными : с помощью секционирования таблиц вы можете легко управлять большими наборами данных, разделяя их на более мелкие, более управляемые секции. Это может упростить такие задачи, как архивирование данных, очистка данных, а также операции резервного копирования и восстановления.

3. Улучшенная загрузка и индексация данных : при загрузке данных в секционированную таблицу процесс может быть распараллелен, что приводит к более быстрому приему данных. Кроме того, индексы в секционированных таблицах могут быть более эффективными, поскольку им нужно охватывать только меньший подмножество данных.

4.Экономичное хранение : разделение позволяет хранить старые или редко используемые данные на более дешевых носителях, а часто используемые данные — на более быстрых устройствах хранения.


Существует два основных варианта партиционирования в SQL — горизонтальное и вертикальное.

Горизонтальное партиционирование предполагает разделение таблицы на партиции, основанное на строках. Каждая партиция содержит определенное количество строк. Такой подход используется, когда таблица имеет очень большой объем данных и необходима более эффективная обработка.

Вертикальное партиционирование, в свою очередь, разделяет таблицу на партиции, основываясь на столбцах. Каждая партиция содержит определенный набор столбцов. Такой подход может быть полезным, когда таблица имеет много столбцов и только некоторые из них часто используются.

Комбинация горизонтального и вертикального - Редкое сочетание горизонтального и вертикального разбиения, которое делит таблицу как по строкам, так и по столбцам.



В целом, принцип партиционирования во всех СУБД одинаковый, но как всегда есть нюансы.
Для конкретики, разберем устройство партиционивания в PostgreSQL.

PostgreSQL предлагает различные методы секционирования, в том числе:

- Разделение диапазона

- Разделение списка

- Разделение хэша


### **Разделение диапазона (Range Partitioning)**

Принцип работы: Таблица разделяется на партиции по диапазонам значений ключевого столбца. Каждая партиция содержит данные, попадающие в определенный диапазон.

Когда использовать:

Для временных данных (по датам, месяцам, годам)

Для числовых значений с естественными диапазонами (например, суммы, возраст)

Пример:

```
-- Создаем основную партиционированную таблицу
CREATE TABLE sales (
    id SERIAL,
    sale_date DATE NOT NULL,
    product_id INT,
    amount DECIMAL(10, 2)
) PARTITION BY RANGE (sale_date);

-- Создаем партиции для каждого квартала 2023 года
CREATE TABLE sales_q1_2023 PARTITION OF sales
    FOR VALUES FROM ('2023-01-01') TO ('2023-04-01');

CREATE TABLE sales_q2_2023 PARTITION OF sales
    FOR VALUES FROM ('2023-04-01') TO ('2023-07-01');

CREATE TABLE sales_q3_2023 PARTITION OF sales
    FOR VALUES FROM ('2023-07-01') TO ('2023-10-01');

CREATE TABLE sales_q4_2023 PARTITION OF sales
    FOR VALUES FROM ('2023-10-01') TO ('2024-01-01');

-- Создаем дефолтную партицию для данных вне указанных диапазонов
CREATE TABLE sales_default PARTITION OF sales DEFAULT;
```

Особенности:

Диапазоны не должны пересекаться

Можно создавать партиции заранее для будущих данных

Эффективно для запросов с условиями по ключу партиционирования

### **Разделение списка (List Partitioning)**
Принцип работы: Таблица разделяется на партиции по списку значений ключевого столбца. Каждая партиция содержит данные с определенными значениями.

Когда использовать:

- Когда данные естественным образом группируются по дискретным значениям

- Для географических регионов, категорий продуктов и т.д.

Пример:

```
-- Создаем основную партиционированную таблицу
CREATE TABLE employees (
    id SERIAL,
    name TEXT,
    department TEXT,
    salary DECIMAL(10, 2)
) PARTITION BY LIST (department);

-- Создаем партиции для каждого отдела
CREATE TABLE employees_hr PARTITION OF employees
    FOR VALUES IN ('HR', 'Human Resources');

CREATE TABLE employees_it PARTITION OF employees
    FOR VALUES IN ('IT', 'Information Technology');

CREATE TABLE employees_sales PARTITION OF employees
    FOR VALUES IN ('Sales', 'Marketing');

CREATE TABLE employees_finance PARTITION OF employees
    FOR VALUES IN ('Finance', 'Accounting');

-- Партиция для всех остальных отделов
CREATE TABLE employees_default PARTITION OF employees DEFAULT;
```

Особенности:

- Значения в списке не должны пересекаться между партициями

- Хорошо подходит для данных с известным набором категорий

- Эффективно для запросов с фильтрацией по категориям

### **Разделение хэша (Hash Partitioning)**
Принцип работы: Таблица разделяется на партиции с использованием хэш-функции от значения ключевого столбца. Данные распределяются по партициям равномерно.

Когда использовать:

- Когда нет естественного критерия для диапазонного или спискового разделения

- Для равномерного распределения данных и нагрузки

- Для больших таблиц, где важна параллельная обработка

Пример:

```
-- Создаем основную партиционированную таблицу
CREATE TABLE user_sessions (
    session_id UUID,
    user_id BIGINT,
    created_at TIMESTAMP,
    session_data JSONB
) PARTITION BY HASH (user_id);

-- Создаем 4 партиции, используя остаток от деления хэша
CREATE TABLE user_sessions_p0 PARTITION OF user_sessions
    FOR VALUES WITH (MODULUS 4, REMAINDER 0);

CREATE TABLE user_sessions_p1 PARTITION OF user_sessions
    FOR VALUES WITH (MODULUS 4, REMAINDER 1);

CREATE TABLE user_sessions_p2 PARTITION OF user_sessions
    FOR VALUES WITH (MODULUS 4, REMAINDER 2);

CREATE TABLE user_sessions_p3 PARTITION OF user_sessions
    FOR VALUES WITH (MODULUS 4, REMAINDER 3);

 ```

Особенности:

- Обеспечивает равномерное распределение данных

- Количество партиций лучше выбирать степенью двойки

- Не поддерживает исключение партиций при запросах (partition pruning) так же эффективно, как range/list

- Хорошо подходит для распределения нагрузки при параллельных операциях
- 


PostgreSQL также поддерживает:

- Композитное партиционирование (сочетание разных методов)

- Присоединение внешних таблиц как партиций (с PostgreSQL 12)

- Автоматическое создание партиций (с помощью расширений)


